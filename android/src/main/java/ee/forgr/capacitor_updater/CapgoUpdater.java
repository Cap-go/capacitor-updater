/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ee.forgr.capacitor_updater;

import android.app.Activity;
import android.content.Context;
import android.content.SharedPreferences;
import android.os.Build;
import androidx.annotation.NonNull;
import androidx.lifecycle.LifecycleOwner;
import androidx.work.Data;
import androidx.work.WorkInfo;
import androidx.work.WorkManager;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import okhttp3.*;
import okhttp3.HttpUrl;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

public class CapgoUpdater {

    private final Logger logger;

    private static final String AB = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    private static final SecureRandom rnd = new SecureRandom();

    private static final String INFO_SUFFIX = "_info";

    private static final String FALLBACK_VERSION = "pastVersion";
    private static final String NEXT_VERSION = "nextVersion";
    private static final String bundleDirectory = "versions";
    private static final String TEMP_UNZIP_PREFIX = "capgo_unzip_";

    public static final String TAG = "Capacitor-updater";
    public SharedPreferences.Editor editor;
    public SharedPreferences prefs;

    public File documentsDir;
    public Boolean directUpdate = false;
    public Activity activity;
    public String pluginVersion = "";
    public String versionBuild = "";
    public String versionCode = "";
    public String versionOs = "";
    public String CAP_SERVER_PATH = "";

    public String customId = "";
    public String statsUrl = "";
    public String channelUrl = "";
    public String defaultChannel = "";
    public String appId = "";
    public String publicKey = "";
    public String deviceID = "";
    public int timeout = 20000;

    // Cached key ID calculated once from publicKey
    private String cachedKeyId = "";

    // Flag to track if we received a 429 response - stops requests until app restart
    private static volatile boolean rateLimitExceeded = false;

    // Flag to track if we've already sent the rate limit statistic - prevents infinite loop
    private static volatile boolean rateLimitStatisticSent = false;

    // Stats batching - queue events and send max once per second
    private final List<JSONObject> statsQueue = new CopyOnWriteArrayList<>();
    private final ScheduledExecutorService statsScheduler = Executors.newSingleThreadScheduledExecutor();
    private ScheduledFuture<?> statsFlushTask = null;
    private static final long STATS_FLUSH_INTERVAL_MS = 1000;

    private final Map<String, CompletableFuture<BundleInfo>> downloadFutures = new ConcurrentHashMap<>();
    private final ExecutorService io = Executors.newSingleThreadExecutor();

    public CapgoUpdater(Logger logger) {
        this.logger = logger;
    }

    private final FilenameFilter filter = (f, name) -> {
        // ignore directories generated by mac os x
        return (!name.startsWith("__MACOSX") && !name.startsWith(".") && !name.startsWith(".DS_Store"));
    };

    private boolean isProd() {
        try {
            if (activity == null) {
                return true; // Default to production if no activity context
            }
            return (activity.getApplicationInfo().flags & android.content.pm.ApplicationInfo.FLAG_DEBUGGABLE) == 0;
        } catch (Exception e) {
            return true; // Default to production if we can't determine
        }
    }

    private boolean isEmulator() {
        return (
            (Build.BRAND.startsWith("generic") && Build.DEVICE.startsWith("generic")) ||
            Build.FINGERPRINT.startsWith("generic") ||
            Build.FINGERPRINT.startsWith("unknown") ||
            Build.HARDWARE.contains("goldfish") ||
            Build.HARDWARE.contains("ranchu") ||
            Build.MODEL.contains("google_sdk") ||
            Build.MODEL.contains("Emulator") ||
            Build.MODEL.contains("Android SDK built for x86") ||
            Build.MANUFACTURER.contains("Genymotion") ||
            Build.PRODUCT.contains("sdk_google") ||
            Build.PRODUCT.contains("google_sdk") ||
            Build.PRODUCT.contains("sdk") ||
            Build.PRODUCT.contains("sdk_x86") ||
            Build.PRODUCT.contains("sdk_gphone64_arm64") ||
            Build.PRODUCT.contains("vbox86p") ||
            Build.PRODUCT.contains("emulator") ||
            Build.PRODUCT.contains("simulator")
        );
    }

    private int calcTotalPercent(final int percent, final int min, final int max) {
        return (percent * (max - min)) / 100 + min;
    }

    void notifyDownload(final String id, final int percent) {}

    void directUpdateFinish(final BundleInfo latest) {}

    void notifyListeners(final String id, final Map<String, Object> res) {}

    public String randomString() {
        final StringBuilder sb = new StringBuilder(10);
        for (int i = 0; i < 10; i++) sb.append(AB.charAt(rnd.nextInt(AB.length())));
        return sb.toString();
    }

    public void setPublicKey(String publicKey) {
        // Empty string means no encryption - proceed normally
        if (publicKey == null || publicKey.isEmpty()) {
            this.publicKey = "";
            this.cachedKeyId = "";
            return;
        }

        // Non-empty: must be a valid RSA key or crash
        try {
            CryptoCipher.stringToPublicKey(publicKey);
        } catch (Exception e) {
            throw new RuntimeException(
                "Invalid public key in capacitor.config.json: failed to parse RSA key. Remove the key or provide a valid PEM-formatted RSA public key.",
                e
            );
        }

        this.publicKey = publicKey;
        this.cachedKeyId = CryptoCipher.calcKeyId(publicKey);
    }

    public String getKeyId() {
        return this.cachedKeyId;
    }

    private File unzip(final String id, final File zipFile, final String dest) throws IOException {
        final File targetDirectory = new File(this.documentsDir, dest);
        try (
            final BufferedInputStream bis = new BufferedInputStream(new FileInputStream(zipFile));
            final ZipInputStream zis = new ZipInputStream(bis)
        ) {
            int count;
            final int bufferSize = 8192;
            final byte[] buffer = new byte[bufferSize];
            final long lengthTotal = zipFile.length();
            long lengthRead = bufferSize;
            int percent = 0;
            this.notifyDownload(id, 75);

            ZipEntry entry;
            while ((entry = zis.getNextEntry()) != null) {
                if (entry.getName().contains("\\")) {
                    logger.error("Unzip failed: Windows path not supported");
                    logger.debug("Invalid path: " + entry.getName());
                    this.sendStats("windows_path_fail");
                }
                final File file = new File(targetDirectory, entry.getName());
                final String canonicalPath = file.getCanonicalPath();
                final String canonicalDir = targetDirectory.getCanonicalPath();
                final File dir = entry.isDirectory() ? file : file.getParentFile();

                if (!canonicalPath.startsWith(canonicalDir)) {
                    this.sendStats("canonical_path_fail");
                    throw new FileNotFoundException(
                        "SecurityException, Failed to ensure directory is the start path : " + canonicalDir + " of " + canonicalPath
                    );
                }

                assert dir != null;
                if (!dir.isDirectory() && !dir.mkdirs()) {
                    this.sendStats("directory_path_fail");
                    throw new FileNotFoundException("Failed to ensure directory: " + dir.getAbsolutePath());
                }

                if (entry.isDirectory()) {
                    continue;
                }

                try (final FileOutputStream outputStream = new FileOutputStream(file)) {
                    while ((count = zis.read(buffer)) != -1) outputStream.write(buffer, 0, count);
                }

                final int newPercent = (int) ((lengthRead / (float) lengthTotal) * 100);
                if (lengthTotal > 1 && newPercent != percent) {
                    percent = newPercent;
                    this.notifyDownload(id, this.calcTotalPercent(percent, 75, 90));
                }

                lengthRead += entry.getCompressedSize();
            }
            return targetDirectory;
        } catch (IOException e) {
            this.sendStats("unzip_fail");
            throw new IOException("Failed to unzip: " + zipFile.getPath());
        }
    }

    private void flattenAssets(final File sourceFile, final String dest) throws IOException {
        if (!sourceFile.exists()) {
            throw new FileNotFoundException("Source file not found: " + sourceFile.getPath());
        }
        final File destinationFile = new File(this.documentsDir, dest);
        Objects.requireNonNull(destinationFile.getParentFile()).mkdirs();
        final String[] entries = sourceFile.list(this.filter);
        if (entries == null || entries.length == 0) {
            throw new IOException("Source file was not a directory or was empty: " + sourceFile.getPath());
        }
        if (entries.length == 1 && !"index.html".equals(entries[0])) {
            final File child = new File(sourceFile, entries[0]);
            if (!child.renameTo(destinationFile)) {
                throw new IOException(
                    "Failed to move bundle contents: " + child.getPath() + " -> " + destinationFile.getPath()
                );
            }
        } else {
            if (!sourceFile.renameTo(destinationFile)) {
                throw new IOException(
                    "Failed to move bundle contents: " + sourceFile.getPath() + " -> " + destinationFile.getPath()
                );
            }
        }
        sourceFile.delete();
    }

    private void cacheBundleFilesAsync(final String id) {
        io.execute(() -> cacheBundleFiles(id));
    }

    private void cacheBundleFiles(final String id) {
        if (this.activity == null) {
            logger.debug("Skip delta cache population: activity is null");
            return;
        }

        final File bundleDir = this.getBundleDirectory(id);
        if (!bundleDir.exists()) {
            logger.debug("Skip delta cache population: bundle dir missing");
            return;
        }

        final File cacheDir = new File(this.activity.getCacheDir(), "capgo_downloads");
        if (!cacheDir.exists() && !cacheDir.mkdirs()) {
            logger.debug("Skip delta cache population: failed to create cache dir");
            return;
        }

        final List<File> files = new ArrayList<>();
        collectFiles(bundleDir, files);
        for (File file : files) {
            final String checksum = CryptoCipher.calcChecksum(file);
            if (checksum.isEmpty()) {
                continue;
            }
            final String cacheName = checksum + "_" + file.getName();
            final File cacheFile = new File(cacheDir, cacheName);
            if (cacheFile.exists()) {
                continue;
            }
            try {
                copyFile(file, cacheFile);
            } catch (IOException e) {
                logger.debug("Delta cache copy failed: " + file.getPath());
            }
        }
    }

    private void collectFiles(final File dir, final List<File> files) {
        final File[] entries = dir.listFiles();
        if (entries == null) {
            return;
        }
        for (File entry : entries) {
            if (!this.filter.accept(dir, entry.getName())) {
                continue;
            }
            if (entry.isDirectory()) {
                collectFiles(entry, files);
            } else if (entry.isFile()) {
                files.add(entry);
            }
        }
    }

    private void copyFile(final File source, final File dest) throws IOException {
        try (final FileInputStream input = new FileInputStream(source); final FileOutputStream output = new FileOutputStream(dest)) {
            final byte[] buffer = new byte[1024 * 1024];
            int length;
            while ((length = input.read(buffer)) != -1) {
                output.write(buffer, 0, length);
            }
        }
    }

    private void observeWorkProgress(Context context, String id) {
        if (!(context instanceof LifecycleOwner)) {
            logger.error("Context is not a LifecycleOwner, cannot observe work progress");
            return;
        }

        activity.runOnUiThread(() -> {
            WorkManager.getInstance(context)
                .getWorkInfosByTagLiveData(id)
                .observe((LifecycleOwner) context, (workInfos) -> {
                    if (workInfos == null || workInfos.isEmpty()) return;

                    WorkInfo workInfo = workInfos.get(0);
                    Data progress = workInfo.getProgress();

                    switch (workInfo.getState()) {
                        case RUNNING:
                            int percent = progress.getInt(DownloadService.PERCENT, 0);
                            notifyDownload(id, percent);
                            break;
                        case SUCCEEDED:
                            logger.info("Download succeeded: " + workInfo.getState());
                            Data outputData = workInfo.getOutputData();
                            String dest = outputData.getString(DownloadService.FILEDEST);
                            String version = outputData.getString(DownloadService.VERSION);
                            String sessionKey = outputData.getString(DownloadService.SESSIONKEY);
                            String checksum = outputData.getString(DownloadService.CHECKSUM);
                            boolean isManifest = outputData.getBoolean(DownloadService.IS_MANIFEST, false);

                            io.execute(() -> {
                                boolean success = finishDownload(id, dest, version, sessionKey, checksum, true, isManifest);
                                BundleInfo resultBundle;
                                if (!success) {
                                    logger.error("Finish download failed");
                                    logger.debug("Version: " + version);
                                    resultBundle = new BundleInfo(
                                        id,
                                        version,
                                        BundleStatus.ERROR,
                                        new Date(System.currentTimeMillis()),
                                        ""
                                    );
                                    saveBundleInfo(id, resultBundle);
                                    // Cleanup download tracking
                                    DownloadWorkerManager.cancelBundleDownload(activity, id, version);
                                    Map<String, Object> ret = new HashMap<>();
                                    ret.put("version", version);
                                    ret.put("error", "finish_download_fail");
                                    sendStats("finish_download_fail", version);
                                    notifyListeners("downloadFailed", ret);
                                } else {
                                    // Successful download - cleanup tracking
                                    DownloadWorkerManager.cancelBundleDownload(activity, id, version);
                                    resultBundle = getBundleInfo(id);
                                }

                                // Complete the future if it exists
                                CompletableFuture<BundleInfo> future = downloadFutures.remove(id);
                                if (future != null) {
                                    future.complete(resultBundle);
                                }
                            });
                            break;
                        case FAILED:
                            Data failedData = workInfo.getOutputData();
                            String error = failedData.getString(DownloadService.ERROR);
                            logger.error("Download failed");
                            logger.debug("Error: " + error + ", State: " + workInfo.getState());
                            String failedVersion = failedData.getString(DownloadService.VERSION);

                            io.execute(() -> {
                                BundleInfo failedBundle = new BundleInfo(
                                    id,
                                    failedVersion,
                                    BundleStatus.ERROR,
                                    new Date(System.currentTimeMillis()),
                                    ""
                                );
                                saveBundleInfo(id, failedBundle);
                                // Cleanup download tracking for failed downloads
                                DownloadWorkerManager.cancelBundleDownload(activity, id, failedVersion);
                                Map<String, Object> ret = new HashMap<>();
                                ret.put("version", failedVersion);
                                if ("low_mem_fail".equals(error)) {
                                    sendStats("low_mem_fail", failedVersion);
                                }
                                ret.put("error", error != null ? error : "download_fail");
                                sendStats("download_fail", failedVersion);
                                notifyListeners("downloadFailed", ret);

                                // Complete the future with error status
                                CompletableFuture<BundleInfo> failedFuture = downloadFutures.remove(id);
                                if (failedFuture != null) {
                                    failedFuture.complete(failedBundle);
                                }
                            });
                            break;
                    }
                });
        });
    }

    private void download(
        final String id,
        final String url,
        final String dest,
        final String version,
        final String sessionKey,
        final String checksum,
        final JSONArray manifest
    ) {
        if (this.activity == null) {
            logger.error("Activity is null, cannot observe work progress");
            return;
        }
        observeWorkProgress(this.activity, id);

        DownloadWorkerManager.enqueueDownload(
            this.activity,
            url,
            id,
            this.documentsDir.getAbsolutePath(),
            dest,
            version,
            sessionKey,
            checksum,
            this.publicKey,
            manifest != null,
            this.isEmulator(),
            this.appId,
            this.pluginVersion,
            this.isProd(),
            this.statsUrl,
            this.deviceID,
            this.versionBuild,
            this.versionCode,
            this.versionOs,
            this.customId,
            this.defaultChannel
        );

        if (manifest != null) {
            DataManager.getInstance().setManifest(manifest);
        }
    }

    public Boolean finishDownload(
        String id,
        String dest,
        String version,
        String sessionKey,
        String checksumRes,
        Boolean setNext,
        Boolean isManifest
    ) {
        File downloaded = null;
        File extractedDir = null;
        String checksum = "";

        try {
            this.notifyDownload(id, 71);
            downloaded = new File(this.documentsDir, dest);

            if (!isManifest) {
                String checksumDecrypted = Objects.requireNonNullElse(checksumRes, "");

                // If public key is present but no checksum provided, refuse installation
                if (!this.publicKey.isEmpty() && checksumDecrypted.isEmpty()) {
                    logger.error("Public key present but no checksum provided");
                    this.sendStats("checksum_required");
                    throw new IOException("Checksum required when public key is present: " + id);
                }

                if (!sessionKey.isEmpty()) {
                    CryptoCipher.decryptFile(downloaded, publicKey, sessionKey);
                    checksumDecrypted = CryptoCipher.decryptChecksum(checksumRes, publicKey);
                    checksum = CryptoCipher.calcChecksum(downloaded);
                } else {
                    checksum = CryptoCipher.calcChecksum(downloaded);
                }
                CryptoCipher.logChecksumInfo("Calculated checksum", checksum);
                CryptoCipher.logChecksumInfo("Expected checksum", checksumDecrypted);
                if ((!checksumDecrypted.isEmpty() || !this.publicKey.isEmpty()) && !checksumDecrypted.equals(checksum)) {
                    logger.error("Checksum mismatch");
                    logger.debug("Expected: " + checksumDecrypted + ", Got: " + checksum);
                    this.sendStats("checksum_fail");
                    throw new IOException("Checksum failed: " + id);
                }
            }
            // Remove the decryption for manifest downloads
        } catch (Exception e) {
            if (!isManifest) {
                safeDelete(downloaded);
            }
            final Boolean res = this.delete(id);
            if (!res) {
                logger.info("Failed to cleanup after error");
                logger.debug("Version: " + version);
            }

            final Map<String, Object> ret = new HashMap<>();
            ret.put("version", version);

            CapgoUpdater.this.notifyListeners("downloadFailed", ret);
            CapgoUpdater.this.sendStats("download_fail");
            return false;
        }

        try {
            if (!isManifest) {
                extractedDir = this.unzip(id, downloaded, TEMP_UNZIP_PREFIX + this.randomString());
                this.notifyDownload(id, 91);
                final String idName = bundleDirectory + "/" + id;
                this.flattenAssets(extractedDir, idName);
                this.cacheBundleFilesAsync(id);
            } else {
                this.notifyDownload(id, 91);
                final String idName = bundleDirectory + "/" + id;
                this.flattenAssets(downloaded, idName);
                downloaded.delete();
            }
            // Remove old bundle info and set new one
            this.saveBundleInfo(id, null);
            BundleInfo next = new BundleInfo(id, version, BundleStatus.PENDING, new Date(System.currentTimeMillis()), checksum);
            this.saveBundleInfo(id, next);
            this.notifyDownload(id, 100);

            final Map<String, Object> ret = new HashMap<>();
            ret.put("bundle", next.toJSONMap());
            logger.info("updateAvailable: " + ret);
            CapgoUpdater.this.notifyListeners("updateAvailable", ret);
            logger.info("setNext: " + setNext);
            if (setNext) {
                logger.info("directUpdate: " + this.directUpdate);
                if (this.directUpdate) {
                    CapgoUpdater.this.directUpdateFinish(next);
                    this.directUpdate = false;
                } else {
                    this.setNextBundle(next.getId());
                }
            }
        } catch (IOException e) {
            if (!isManifest) {
                safeDelete(extractedDir);
                safeDelete(downloaded);
            }
            e.printStackTrace();
            final Map<String, Object> ret = new HashMap<>();
            ret.put("version", version);
            CapgoUpdater.this.notifyListeners("downloadFailed", ret);
            CapgoUpdater.this.sendStats("download_fail");
            return false;
        }
        if (!isManifest) {
            safeDelete(downloaded);
        }
        return true;
    }

    private void deleteDirectory(final File file) throws IOException {
        deleteDirectory(file, null);
    }

    private void deleteDirectory(final File file, final Thread threadToCheck) throws IOException {
        // Check if thread was interrupted (cancelled)
        if (threadToCheck != null && threadToCheck.isInterrupted()) {
            throw new IOException("Operation cancelled");
        }

        if (file.isDirectory()) {
            final File[] entries = file.listFiles();
            if (entries != null) {
                for (final File entry : entries) {
                    this.deleteDirectory(entry, threadToCheck);
                }
            }
        }
        if (!file.delete()) {
            throw new IOException("Failed to delete: " + file);
        }
    }

    public void cleanupDeltaCache() {
        cleanupDeltaCache(null);
    }

    public void cleanupDeltaCache(final Thread threadToCheck) {
        if (this.activity == null) {
            logger.warn("Activity is null, skipping delta cache cleanup");
            return;
        }
        final File cacheFolder = new File(this.activity.getCacheDir(), "capgo_downloads");
        if (!cacheFolder.exists()) {
            return;
        }
        try {
            this.deleteDirectory(cacheFolder, threadToCheck);
            logger.info("Cleaned up delta cache folder");
        } catch (IOException e) {
            logger.error("Failed to cleanup delta cache");
            logger.debug("Error: " + e.getMessage());
        }
    }

    public void cleanupDownloadDirectories(final Set<String> allowedIds) {
        cleanupDownloadDirectories(allowedIds, null);
    }

    public void cleanupDownloadDirectories(final Set<String> allowedIds, final Thread threadToCheck) {
        if (this.documentsDir == null) {
            logger.warn("Documents directory is null, skipping download cleanup");
            return;
        }

        final File bundleRoot = new File(this.documentsDir, bundleDirectory);
        if (!bundleRoot.exists() || !bundleRoot.isDirectory()) {
            return;
        }

        final File[] entries = bundleRoot.listFiles();
        if (entries != null) {
            for (final File entry : entries) {
                // Check if thread was interrupted (cancelled)
                if (threadToCheck != null && threadToCheck.isInterrupted()) {
                    logger.warn("cleanupDownloadDirectories was cancelled");
                    return;
                }

                if (!entry.isDirectory()) {
                    continue;
                }

                final String id = entry.getName();

                if (allowedIds != null && allowedIds.contains(id)) {
                    continue;
                }

                try {
                    this.deleteDirectory(entry, threadToCheck);
                    this.removeBundleInfo(id);
                    logger.info("Deleted orphan bundle directory");
                    logger.debug("Bundle ID: " + id);
                } catch (IOException e) {
                    logger.error("Failed to delete orphan bundle directory");
                    logger.debug("Bundle ID: " + id + ", Error: " + e.getMessage());
                }
            }
        }
    }

    public void cleanupOrphanedTempFolders(final Thread threadToCheck) {
        if (this.documentsDir == null) {
            logger.warn("Documents directory is null, skipping temp folder cleanup");
            return;
        }

        final File[] entries = this.documentsDir.listFiles();
        if (entries == null) {
            return;
        }

        for (final File entry : entries) {
            // Check if thread was interrupted (cancelled)
            if (threadToCheck != null && threadToCheck.isInterrupted()) {
                logger.warn("cleanupOrphanedTempFolders was cancelled");
                return;
            }

            if (!entry.isDirectory()) {
                continue;
            }

            final String folderName = entry.getName();

            // Only delete folders with the temp unzip prefix
            if (!folderName.startsWith(TEMP_UNZIP_PREFIX)) {
                continue;
            }

            try {
                this.deleteDirectory(entry, threadToCheck);
                logger.info("Deleted orphaned temp unzip folder");
                logger.debug("Folder: " + folderName);
            } catch (IOException e) {
                logger.error("Failed to delete orphaned temp folder");
                logger.debug("Folder: " + folderName + ", Error: " + e.getMessage());
            }
        }
    }

    private void safeDelete(final File target) {
        if (target == null || !target.exists()) {
            return;
        }
        try {
            if (target.isDirectory()) {
                this.deleteDirectory(target);
            } else if (!target.delete()) {
                logger.warn("Failed to delete file: " + target.getAbsolutePath());
            }
        } catch (IOException cleanupError) {
            logger.warn("Cleanup failed for " + target.getAbsolutePath() + ": " + cleanupError.getMessage());
        }
    }

    private void setCurrentBundle(final File bundle) {
        this.editor.putString(this.CAP_SERVER_PATH, bundle.getPath());
        logger.info("Current bundle set to: " + bundle);
        this.editor.commit();
    }

    public void downloadBackground(
        final String url,
        final String version,
        final String sessionKey,
        final String checksum,
        final JSONArray manifest
    ) {
        final String id = this.randomString();

        // Check if version is already downloading, but allow retry if previous download failed
        if (this.activity != null && DownloadWorkerManager.isVersionDownloading(this.activity, version)) {
            // Check if there's an existing bundle with error status that we can retry
            BundleInfo existingBundle = this.getBundleInfoByName(version);
            if (existingBundle != null && existingBundle.isErrorStatus()) {
                // Cancel the failed download and allow retry
                DownloadWorkerManager.cancelVersionDownload(this.activity, version);
                logger.info("Retrying failed download for version: " + version);
            } else {
                logger.info("Version already downloading: " + version);
                return;
            }
        }

        saveBundleInfo(id, new BundleInfo(id, version, BundleStatus.DOWNLOADING, new Date(System.currentTimeMillis()), ""));
        this.notifyDownload(id, 0);
        this.notifyDownload(id, 5);

        this.download(id, url, this.randomString(), version, sessionKey, checksum, manifest);
    }

    public BundleInfo download(final String url, final String version, final String sessionKey, final String checksum) throws IOException {
        // Check for existing bundle with same version and clean up if in error state
        BundleInfo existingBundle = this.getBundleInfoByName(version);
        if (existingBundle != null && (existingBundle.isErrorStatus() || existingBundle.isDeleted())) {
            logger.info("Found existing failed bundle for version " + version + ", deleting before retry");
            this.delete(existingBundle.getId(), true);
        }

        final String id = this.randomString();
        saveBundleInfo(id, new BundleInfo(id, version, BundleStatus.DOWNLOADING, new Date(System.currentTimeMillis()), ""));
        this.notifyDownload(id, 0);
        this.notifyDownload(id, 5);
        final String dest = this.randomString();

        // Create a CompletableFuture to track download completion
        CompletableFuture<BundleInfo> downloadFuture = new CompletableFuture<>();
        downloadFutures.put(id, downloadFuture);

        // Start the download
        this.download(id, url, dest, version, sessionKey, checksum, null);

        // Wait for completion without timeout
        try {
            BundleInfo result = downloadFuture.get();
            if (result.isErrorStatus()) {
                throw new IOException("Download failed with status: " + result.getStatus());
            }
            return result;
        } catch (Exception e) {
            // Clean up on failure
            downloadFutures.remove(id);
            logger.error("Error waiting for download");
            logger.debug("Error: " + e.getMessage());
            BundleInfo errorBundle = new BundleInfo(id, version, BundleStatus.ERROR, new Date(System.currentTimeMillis()), "");
            saveBundleInfo(id, errorBundle);
            if (e instanceof IOException) {
                throw (IOException) e;
            }
            throw new IOException("Error waiting for download: " + e.getMessage(), e);
        }
    }

    public List<BundleInfo> list(boolean rawList) {
        if (!rawList) {
            final List<BundleInfo> res = new ArrayList<>();
            final File destHot = new File(this.documentsDir, bundleDirectory);
            logger.debug("list File : " + destHot.getPath());
            if (destHot.exists()) {
                for (final File i : Objects.requireNonNull(destHot.listFiles())) {
                    final String id = i.getName();
                    res.add(this.getBundleInfo(id));
                }
            } else {
                logger.info("No versions available to list" + destHot);
            }
            return res;
        } else {
            final List<BundleInfo> res = new ArrayList<>();
            for (String value : this.prefs.getAll().keySet()) {
                if (!value.matches("^[0-9A-Za-z]{10}_info$")) {
                    continue;
                }

                res.add(this.getBundleInfo(value.split("_")[0]));
            }
            return res;
        }
    }

    public Boolean delete(final String id, final Boolean removeInfo) throws IOException {
        final BundleInfo deleted = this.getBundleInfo(id);
        if (deleted.isBuiltin() || this.getCurrentBundleId().equals(id)) {
            logger.error("Cannot delete current or builtin bundle");
            logger.debug("Bundle ID: " + id);
            return false;
        }
        final BundleInfo next = this.getNextBundle();
        if (next != null && !next.isDeleted() && !next.isErrorStatus() && next.getId().equals(id)) {
            logger.error("Cannot delete the next bundle");
            logger.debug("Bundle ID: " + id);
            return false;
        }
        // Cancel download for this version if active
        if (this.activity != null) {
            DownloadWorkerManager.cancelVersionDownload(this.activity, deleted.getVersionName());
        }
        final File bundle = new File(this.documentsDir, bundleDirectory + "/" + id);
        if (bundle.exists()) {
            this.deleteDirectory(bundle);
            if (!removeInfo) {
                this.saveBundleInfo(id, deleted.setStatus(BundleStatus.DELETED));
            } else {
                this.removeBundleInfo(id);
            }
            return true;
        }
        logger.info("Bundle not found on disk");
        logger.debug("Version: " + deleted.getVersionName());
        // perhaps we did not find the bundle in the files, but if the user requested a delete, we delete
        if (removeInfo) {
            this.removeBundleInfo(id);
        }
        this.sendStats("delete", deleted.getVersionName());
        return false;
    }

    public Boolean delete(final String id) {
        try {
            return this.delete(id, true);
        } catch (IOException e) {
            e.printStackTrace();
            logger.info("Failed to delete bundle (" + id + ")" + "\nError:\n" + e.toString());
            return false;
        }
    }

    private File getBundleDirectory(final String id) {
        return new File(this.documentsDir, bundleDirectory + "/" + id);
    }

    private boolean bundleExists(final String id) {
        final File bundle = this.getBundleDirectory(id);
        final BundleInfo bundleInfo = this.getBundleInfo(id);
        return (bundle.isDirectory() && bundle.exists() && new File(bundle.getPath(), "/index.html").exists() && !bundleInfo.isDeleted());
    }

    public Boolean set(final BundleInfo bundle) {
        return this.set(bundle.getId());
    }

    public Boolean set(final String id) {
        final BundleInfo newBundle = this.getBundleInfo(id);
        if (newBundle.isBuiltin()) {
            this.reset();
            return true;
        }
        final File bundle = this.getBundleDirectory(id);
        logger.info("Setting next active bundle: " + id);
        if (this.bundleExists(id)) {
            var currentBundleName = this.getCurrentBundle().getVersionName();
            this.setCurrentBundle(bundle);
            this.setBundleStatus(id, BundleStatus.PENDING);
            this.sendStats("set", newBundle.getVersionName(), currentBundleName);
            return true;
        }
        this.setBundleStatus(id, BundleStatus.ERROR);
        this.sendStats("set_fail", newBundle.getVersionName());
        return false;
    }

    public void autoReset() {
        final BundleInfo currentBundle = this.getCurrentBundle();
        if (!currentBundle.isBuiltin() && !this.bundleExists(currentBundle.getId())) {
            logger.info("Folder at bundle path does not exist. Triggering reset.");
            this.reset();
        }
    }

    public void reset() {
        this.reset(false);
    }

    public void setSuccess(final BundleInfo bundle, Boolean autoDeletePrevious) {
        this.setBundleStatus(bundle.getId(), BundleStatus.SUCCESS);
        final BundleInfo fallback = this.getFallbackBundle();
        logger.debug("Fallback bundle is: " + fallback);
        logger.info("Version successfully loaded: " + bundle.getVersionName());
        // Only attempt to delete when the fallback is a different bundle than the
        // currently loaded one. Otherwise we spam logs with "Cannot delete <id>"
        // because delete() protects the current bundle from removal.
        if (autoDeletePrevious && !fallback.isBuiltin() && fallback.getId() != null && !fallback.getId().equals(bundle.getId())) {
            final Boolean res = this.delete(fallback.getId());
            if (res) {
                logger.info("Deleted previous bundle: " + fallback.getVersionName());
            } else {
                logger.debug("Skip deleting previous bundle (same as current or protected): " + fallback.getId());
            }
        }
        this.setFallbackBundle(bundle);
    }

    public void setError(final BundleInfo bundle) {
        this.setBundleStatus(bundle.getId(), BundleStatus.ERROR);
    }

    public void reset(final boolean internal) {
        logger.debug("reset: " + internal);
        var currentBundleName = this.getCurrentBundle().getVersionName();
        this.setCurrentBundle(new File("public"));
        this.setFallbackBundle(null);
        this.setNextBundle(null);
        // Cancel any ongoing downloads
        if (this.activity != null) {
            DownloadWorkerManager.cancelAllDownloads(this.activity);
        }
        if (!internal) {
            this.sendStats("reset", this.getCurrentBundle().getVersionName(), currentBundleName);
        }
    }

    private JSONObject createInfoObject() throws JSONException {
        JSONObject json = new JSONObject();
        json.put("platform", "android");
        json.put("device_id", this.deviceID);
        json.put("app_id", this.appId);
        json.put("custom_id", this.customId);
        json.put("version_build", this.versionBuild);
        json.put("version_code", this.versionCode);
        json.put("version_os", this.versionOs);
        json.put("version_name", this.getCurrentBundle().getVersionName());
        json.put("plugin_version", this.pluginVersion);
        json.put("is_emulator", this.isEmulator());
        json.put("is_prod", this.isProd());
        json.put("defaultChannel", this.defaultChannel);

        // Add encryption key ID if encryption is enabled (use cached value)
        if (!this.cachedKeyId.isEmpty()) {
            json.put("key_id", this.cachedKeyId);
        }

        return json;
    }

    /**
     * Check if a 429 (Too Many Requests) response was received and set the flag
     */
    private boolean checkAndHandleRateLimitResponse(Response response) {
        if (response.code() == 429) {
            // Send a statistic about the rate limit BEFORE setting the flag
            // Only send once to prevent infinite loop if the stat request itself gets rate limited
            if (!rateLimitExceeded && !rateLimitStatisticSent) {
                rateLimitStatisticSent = true;
                sendRateLimitStatistic();
            }
            rateLimitExceeded = true;
            logger.warn("Rate limit exceeded (429). Stopping all stats and channel requests until app restart.");
            return true;
        }
        return false;
    }

    /**
     * Send a synchronous statistic about rate limiting
     */
    private void sendRateLimitStatistic() {
        String statsUrl = this.statsUrl;
        if (statsUrl == null || statsUrl.isEmpty()) {
            return;
        }

        try {
            BundleInfo current = this.getCurrentBundle();
            JSONObject json = this.createInfoObject();
            json.put("version_name", current.getVersionName());
            json.put("old_version_name", "");
            json.put("action", "rate_limit_reached");

            Request request = new Request.Builder()
                .url(statsUrl)
                .post(RequestBody.create(json.toString(), MediaType.get("application/json")))
                .build();

            // Send synchronously to ensure it goes out before the flag is set
            // User-Agent header is automatically added by DownloadService.sharedClient interceptor
            try (Response response = DownloadService.sharedClient.newCall(request).execute()) {
                if (response.isSuccessful()) {
                    logger.info("Rate limit statistic sent");
                } else {
                    logger.error("Error sending rate limit statistic");
                    logger.debug("Response code: " + response.code());
                }
            }
        } catch (final Exception e) {
            logger.error("Failed to send rate limit statistic");
            logger.debug("Error: " + e.getMessage());
        }
    }

    private void makeJsonRequest(String url, JSONObject jsonBody, Callback callback) {
        MediaType JSON = MediaType.get("application/json; charset=utf-8");
        RequestBody body = RequestBody.create(jsonBody.toString(), JSON);

        Request request = new Request.Builder().url(url).post(body).build();

        DownloadService.sharedClient
            .newCall(request)
            .enqueue(
                new okhttp3.Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        Map<String, Object> retError = new HashMap<>();
                        retError.put("message", "Request failed: " + e.getMessage());
                        retError.put("error", "network_error");
                        callback.callback(retError);
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                        try (ResponseBody responseBody = response.body()) {
                            final int statusCode = response.code();
                            // Check for 429 rate limit
                            if (checkAndHandleRateLimitResponse(response)) {
                                Map<String, Object> retError = new HashMap<>();
                                retError.put("message", "Rate limit exceeded");
                                retError.put("error", "rate_limit_exceeded");
                                retError.put("statusCode", statusCode);
                                callback.callback(retError);
                                return;
                            }

                            if (!response.isSuccessful()) {
                                Map<String, Object> retError = new HashMap<>();
                                retError.put("message", "Server error: " + response.code());
                                retError.put("error", "response_error");
                                retError.put("statusCode", statusCode);
                                callback.callback(retError);
                                return;
                            }

                            assert responseBody != null;
                            String responseData = responseBody.string();
                            JSONObject jsonResponse = new JSONObject(responseData);

                            // Check for server-side errors first
                            if (jsonResponse.has("error")) {
                                Map<String, Object> retError = new HashMap<>();
                                retError.put("error", jsonResponse.getString("error"));
                                if (jsonResponse.has("message")) {
                                    retError.put("message", jsonResponse.getString("message"));
                                } else {
                                    retError.put("message", "server did not provide a message");
                                }
                                retError.put("statusCode", statusCode);
                                callback.callback(retError);
                                return;
                            }

                            Map<String, Object> ret = new HashMap<>();
                            ret.put("statusCode", statusCode);

                            Iterator<String> keys = jsonResponse.keys();
                            while (keys.hasNext()) {
                                String key = keys.next();
                                if (jsonResponse.has(key)) {
                                    if ("session_key".equals(key)) {
                                        ret.put("sessionKey", jsonResponse.get(key));
                                    } else {
                                        ret.put(key, jsonResponse.get(key));
                                    }
                                }
                            }
                            callback.callback(ret);
                        } catch (JSONException e) {
                            Map<String, Object> retError = new HashMap<>();
                            retError.put("message", "JSON parse error: " + e.getMessage());
                            retError.put("error", "parse_error");
                            callback.callback(retError);
                        }
                    }
                }
            );
    }

    public void getLatest(final String updateUrl, final String channel, final Callback callback) {
        JSONObject json;
        try {
            json = this.createInfoObject();
            if (channel != null && json != null) {
                json.put("defaultChannel", channel);
            }
        } catch (JSONException e) {
            logger.error("Error getting latest version");
            logger.debug("JSONException: " + e.getMessage());
            final Map<String, Object> retError = new HashMap<>();
            retError.put("message", "Cannot get info: " + e);
            retError.put("error", "json_error");
            callback.callback(retError);
            return;
        }

        logger.info("Auto-update parameters: " + json);

        makeJsonRequest(updateUrl, json, callback);
    }

    public void unsetChannel(
        final SharedPreferences.Editor editor,
        final String defaultChannelKey,
        final String configDefaultChannel,
        final Callback callback
    ) {
        // Clear persisted defaultChannel and revert to config value
        editor.remove(defaultChannelKey);
        editor.apply();
        this.defaultChannel = configDefaultChannel;
        logger.info("Persisted defaultChannel cleared, reverted to config value: " + configDefaultChannel);

        Map<String, Object> ret = new HashMap<>();
        ret.put("status", "ok");
        ret.put("message", "Channel override removed");
        callback.callback(ret);
    }

    public void setChannel(
        final String channel,
        final SharedPreferences.Editor editor,
        final String defaultChannelKey,
        final boolean allowSetDefaultChannel,
        final Callback callback
    ) {
        // Check if setting defaultChannel is allowed
        if (!allowSetDefaultChannel) {
            logger.error("setChannel is disabled by allowSetDefaultChannel config");
            final Map<String, Object> retError = new HashMap<>();
            retError.put("message", "setChannel is disabled by configuration");
            retError.put("error", "disabled_by_config");
            callback.callback(retError);
            return;
        }

        // Check if rate limit was exceeded
        if (rateLimitExceeded) {
            logger.debug("Skipping setChannel due to rate limit (429). Requests will resume after app restart.");
            final Map<String, Object> retError = new HashMap<>();
            retError.put("message", "Rate limit exceeded");
            retError.put("error", "rate_limit_exceeded");
            callback.callback(retError);
            return;
        }

        String channelUrl = this.channelUrl;
        if (channelUrl == null || channelUrl.isEmpty()) {
            logger.error("Channel URL is not set");
            final Map<String, Object> retError = new HashMap<>();
            retError.put("message", "channelUrl missing");
            retError.put("error", "missing_config");
            callback.callback(retError);
            return;
        }
        JSONObject json;
        try {
            json = this.createInfoObject();
            json.put("channel", channel);
        } catch (JSONException e) {
            logger.error("Error setting channel");
            logger.debug("JSONException: " + e.getMessage());
            final Map<String, Object> retError = new HashMap<>();
            retError.put("message", "Cannot get info: " + e);
            retError.put("error", "json_error");
            callback.callback(retError);
            return;
        }

        makeJsonRequest(channelUrl, json, (res) -> {
            if (res.containsKey("error")) {
                callback.callback(res);
            } else {
                // Success - persist defaultChannel
                this.defaultChannel = channel;
                editor.putString(defaultChannelKey, channel);
                editor.apply();
                logger.info("defaultChannel persisted locally: " + channel);
                callback.callback(res);
            }
        });
    }

    public void getChannel(final Callback callback) {
        // Check if rate limit was exceeded
        if (rateLimitExceeded) {
            logger.debug("Skipping getChannel due to rate limit (429). Requests will resume after app restart.");
            final Map<String, Object> retError = new HashMap<>();
            retError.put("message", "Rate limit exceeded");
            retError.put("error", "rate_limit_exceeded");
            callback.callback(retError);
            return;
        }

        String channelUrl = this.channelUrl;
        if (channelUrl == null || channelUrl.isEmpty()) {
            logger.error("Channel URL is not set");
            final Map<String, Object> retError = new HashMap<>();
            retError.put("message", "Channel URL is not set");
            retError.put("error", "missing_config");
            callback.callback(retError);
            return;
        }
        JSONObject json;
        try {
            json = this.createInfoObject();
        } catch (JSONException e) {
            logger.error("Error getting channel");
            logger.debug("JSONException: " + e.getMessage());
            final Map<String, Object> retError = new HashMap<>();
            retError.put("message", "Cannot get info: " + e);
            retError.put("error", "json_error");
            callback.callback(retError);
            return;
        }

        Request request = new Request.Builder()
            .url(channelUrl)
            .put(RequestBody.create(json.toString(), MediaType.get("application/json")))
            .build();

        DownloadService.sharedClient
            .newCall(request)
            .enqueue(
                new okhttp3.Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        Map<String, Object> retError = new HashMap<>();
                        retError.put("message", "Request failed: " + e.getMessage());
                        retError.put("error", "network_error");
                        callback.callback(retError);
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                        try (ResponseBody responseBody = response.body()) {
                            // Check for 429 rate limit
                            if (checkAndHandleRateLimitResponse(response)) {
                                Map<String, Object> retError = new HashMap<>();
                                retError.put("message", "Rate limit exceeded");
                                retError.put("error", "rate_limit_exceeded");
                                callback.callback(retError);
                                return;
                            }

                            if (response.code() == 400) {
                                assert responseBody != null;
                                String data = responseBody.string();
                                if (data.contains("channel_not_found") && !defaultChannel.isEmpty()) {
                                    Map<String, Object> ret = new HashMap<>();
                                    ret.put("channel", defaultChannel);
                                    ret.put("status", "default");
                                    logger.info("Channel get to \"" + ret);
                                    callback.callback(ret);
                                    return;
                                }
                            }

                            if (!response.isSuccessful()) {
                                Map<String, Object> retError = new HashMap<>();
                                retError.put("message", "Server error: " + response.code());
                                retError.put("error", "response_error");
                                callback.callback(retError);
                                return;
                            }

                            assert responseBody != null;
                            String responseData = responseBody.string();
                            JSONObject jsonResponse = new JSONObject(responseData);

                            // Check for server-side errors first
                            if (jsonResponse.has("error")) {
                                Map<String, Object> retError = new HashMap<>();
                                retError.put("error", jsonResponse.getString("error"));
                                if (jsonResponse.has("message")) {
                                    retError.put("message", jsonResponse.getString("message"));
                                } else {
                                    retError.put("message", "server did not provide a message");
                                }
                                callback.callback(retError);
                                return;
                            }

                            Map<String, Object> ret = new HashMap<>();

                            Iterator<String> keys = jsonResponse.keys();
                            while (keys.hasNext()) {
                                String key = keys.next();
                                if (jsonResponse.has(key)) {
                                    ret.put(key, jsonResponse.get(key));
                                }
                            }
                            logger.info("Channel get to \"" + ret);
                            callback.callback(ret);
                        } catch (JSONException e) {
                            Map<String, Object> retError = new HashMap<>();
                            retError.put("message", "JSON parse error: " + e.getMessage());
                            retError.put("error", "parse_error");
                            callback.callback(retError);
                        }
                    }
                }
            );
    }

    public void listChannels(final Callback callback) {
        // Check if rate limit was exceeded
        if (rateLimitExceeded) {
            logger.debug("Skipping listChannels due to rate limit (429). Requests will resume after app restart.");
            final Map<String, Object> retError = new HashMap<>();
            retError.put("message", "Rate limit exceeded");
            retError.put("error", "rate_limit_exceeded");
            callback.callback(retError);
            return;
        }

        String channelUrl = this.channelUrl;
        if (channelUrl == null || channelUrl.isEmpty()) {
            logger.error("Channel URL is not set");
            final Map<String, Object> retError = new HashMap<>();
            retError.put("message", "Channel URL is not set");
            retError.put("error", "missing_config");
            callback.callback(retError);
            return;
        }

        JSONObject json;
        try {
            json = this.createInfoObject();
        } catch (JSONException e) {
            logger.error("Error creating info object");
            logger.debug("JSONException: " + e.getMessage());
            final Map<String, Object> retError = new HashMap<>();
            retError.put("message", "Cannot get info: " + e);
            retError.put("error", "json_error");
            callback.callback(retError);
            return;
        }

        // Build URL with query parameters from JSON
        HttpUrl.Builder urlBuilder = HttpUrl.parse(channelUrl).newBuilder();
        try {
            Iterator<String> keys = json.keys();
            while (keys.hasNext()) {
                String key = keys.next();
                Object value = json.get(key);
                if (value != null) {
                    urlBuilder.addQueryParameter(key, value.toString());
                }
            }
        } catch (JSONException e) {
            logger.error("Error adding query parameters");
            logger.debug("JSONException: " + e.getMessage());
        }

        Request request = new Request.Builder().url(urlBuilder.build()).get().build();

        DownloadService.sharedClient
            .newCall(request)
            .enqueue(
                new okhttp3.Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        Map<String, Object> retError = new HashMap<>();
                        retError.put("message", "Request failed: " + e.getMessage());
                        retError.put("error", "network_error");
                        callback.callback(retError);
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                        try (ResponseBody responseBody = response.body()) {
                            // Check for 429 rate limit
                            if (checkAndHandleRateLimitResponse(response)) {
                                Map<String, Object> retError = new HashMap<>();
                                retError.put("message", "Rate limit exceeded");
                                retError.put("error", "rate_limit_exceeded");
                                callback.callback(retError);
                                return;
                            }

                            if (!response.isSuccessful()) {
                                Map<String, Object> retError = new HashMap<>();
                                retError.put("message", "Server error: " + response.code());
                                retError.put("error", "response_error");
                                callback.callback(retError);
                                return;
                            }

                            assert responseBody != null;
                            String data = responseBody.string();

                            try {
                                Map<String, Object> ret = new HashMap<>();

                                try {
                                    // Try to parse as direct array first
                                    JSONArray channelsJson = new JSONArray(data);
                                    List<Map<String, Object>> channelsList = new ArrayList<>();

                                    for (int i = 0; i < channelsJson.length(); i++) {
                                        JSONObject channelJson = channelsJson.getJSONObject(i);
                                        Map<String, Object> channel = new HashMap<>();
                                        channel.put("id", channelJson.optString("id", ""));
                                        channel.put("name", channelJson.optString("name", ""));
                                        channel.put("public", channelJson.optBoolean("public", false));
                                        channel.put("allow_self_set", channelJson.optBoolean("allow_self_set", false));
                                        channelsList.add(channel);
                                    }

                                    // Wrap in channels object for JS API
                                    ret.put("channels", channelsList);

                                    logger.info("Channels listed successfully");
                                    callback.callback(ret);
                                } catch (JSONException arrayException) {
                                    // If not an array, try to parse as error object
                                    try {
                                        JSONObject json = new JSONObject(data);
                                        if (json.has("error")) {
                                            Map<String, Object> retError = new HashMap<>();
                                            retError.put("error", json.getString("error"));
                                            if (json.has("message")) {
                                                retError.put("message", json.getString("message"));
                                            } else {
                                                retError.put("message", "server did not provide a message");
                                            }
                                            callback.callback(retError);
                                            return;
                                        }
                                    } catch (JSONException objException) {
                                        // If neither array nor object, throw parse error
                                        throw arrayException;
                                    }
                                }
                            } catch (JSONException e) {
                                Map<String, Object> retError = new HashMap<>();
                                retError.put("message", "JSON parse error: " + e.getMessage());
                                retError.put("error", "parse_error");
                                callback.callback(retError);
                            }
                        }
                    }
                }
            );
    }

    public void sendStats(final String action) {
        this.sendStats(action, this.getCurrentBundle().getVersionName());
    }

    public void sendStats(final String action, final String versionName) {
        this.sendStats(action, versionName, "");
    }

    public void sendStats(final String action, final String versionName, final String oldVersionName) {
        // Check if rate limit was exceeded
        if (rateLimitExceeded) {
            logger.debug("Skipping sendStats due to rate limit (429). Stats will resume after app restart.");
            return;
        }

        String statsUrl = this.statsUrl;
        if (statsUrl == null || statsUrl.isEmpty()) {
            return;
        }

        JSONObject json;
        try {
            json = this.createInfoObject();
            json.put("version_name", versionName);
            json.put("old_version_name", oldVersionName);
            json.put("action", action);
            json.put("timestamp", System.currentTimeMillis());
        } catch (JSONException e) {
            logger.error("Error preparing stats");
            logger.debug("JSONException: " + e.getMessage());
            return;
        }

        statsQueue.add(json);
        ensureStatsTimerStarted();
    }

    private synchronized void ensureStatsTimerStarted() {
        if (statsFlushTask == null || statsFlushTask.isCancelled() || statsFlushTask.isDone()) {
            statsFlushTask = statsScheduler.scheduleAtFixedRate(
                this::flushStatsQueue,
                STATS_FLUSH_INTERVAL_MS,
                STATS_FLUSH_INTERVAL_MS,
                TimeUnit.MILLISECONDS
            );
        }
    }

    private void flushStatsQueue() {
        if (statsQueue.isEmpty()) {
            return;
        }

        String statsUrl = this.statsUrl;
        if (statsUrl == null || statsUrl.isEmpty()) {
            statsQueue.clear();
            return;
        }

        // Copy and clear the queue atomically using synchronized block
        List<JSONObject> eventsToSend;
        synchronized (statsQueue) {
            if (statsQueue.isEmpty()) {
                return;
            }
            eventsToSend = new ArrayList<>(statsQueue);
            statsQueue.clear();
        }

        JSONArray jsonArray = new JSONArray();
        for (JSONObject event : eventsToSend) {
            jsonArray.put(event);
        }

        Request request = new Request.Builder()
            .url(statsUrl)
            .post(RequestBody.create(jsonArray.toString(), MediaType.get("application/json")))
            .build();

        final int eventCount = eventsToSend.size();
        DownloadService.sharedClient
            .newCall(request)
            .enqueue(
                new okhttp3.Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        logger.error("Failed to send stats batch");
                        logger.debug("Error: " + e.getMessage());
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                        try (ResponseBody responseBody = response.body()) {
                            // Check for 429 rate limit
                            if (checkAndHandleRateLimitResponse(response)) {
                                return;
                            }

                            if (response.isSuccessful()) {
                                logger.info("Stats batch sent successfully");
                                logger.debug("Sent " + eventCount + " events");
                            } else {
                                logger.error("Error sending stats batch");
                                logger.debug("Response code: " + response.code());
                            }
                        }
                    }
                }
            );
    }

    public BundleInfo getBundleInfo(final String id) {
        String trueId = BundleInfo.VERSION_UNKNOWN;
        if (id != null) {
            trueId = id;
        }
        BundleInfo result;
        if (BundleInfo.ID_BUILTIN.equals(trueId)) {
            result = new BundleInfo(trueId, null, BundleStatus.SUCCESS, "", "");
        } else if (BundleInfo.VERSION_UNKNOWN.equals(trueId)) {
            result = new BundleInfo(trueId, null, BundleStatus.ERROR, "", "");
        } else {
            try {
                String stored = this.prefs.getString(trueId + INFO_SUFFIX, "");
                if (stored.isEmpty()) {
                    result = new BundleInfo(trueId, null, BundleStatus.PENDING, "", "");
                } else {
                    result = BundleInfo.fromJSON(stored);
                }
            } catch (JSONException e) {
                logger.error("Failed to parse bundle info");
                logger.debug("Bundle ID: " + trueId + ", Error: " + e.getMessage());
                // Clear corrupted data
                this.editor.remove(trueId + INFO_SUFFIX);
                this.editor.commit();
                result = new BundleInfo(trueId, null, BundleStatus.ERROR, "", "");
            }
        }
        return result;
    }

    public BundleInfo getBundleInfoByName(final String versionName) {
        final List<BundleInfo> installed = this.list(false);
        for (final BundleInfo i : installed) {
            if (i.getVersionName().equals(versionName)) {
                return i;
            }
        }
        return null;
    }

    private void removeBundleInfo(final String id) {
        this.saveBundleInfo(id, null);
    }

    public void saveBundleInfo(final String id, final BundleInfo info) {
        if (id == null || (info != null && (info.isBuiltin() || info.isUnknown()))) {
            logger.debug("Not saving info for bundle: [" + id + "] " + info);
            return;
        }

        if (info == null) {
            logger.debug("Removing info for bundle [" + id + "]");
            this.editor.remove(id + INFO_SUFFIX);
        } else {
            final BundleInfo update = info.setId(id);
            String jsonString = update.toString();
            logger.debug("Storing info for bundle [" + id + "] " + update.getClass().getName() + " -> " + jsonString);
            this.editor.putString(id + INFO_SUFFIX, jsonString);
        }
        this.editor.commit();
    }

    private void setBundleStatus(final String id, final BundleStatus status) {
        if (id != null && status != null) {
            BundleInfo info = this.getBundleInfo(id);
            logger.debug("Setting status for bundle [" + id + "] to " + status);
            this.saveBundleInfo(id, info.setStatus(status));
        }
    }

    private String getCurrentBundleId() {
        if (this.isUsingBuiltin()) {
            return BundleInfo.ID_BUILTIN;
        } else {
            final String path = this.getCurrentBundlePath();
            return path.substring(path.lastIndexOf('/') + 1);
        }
    }

    public BundleInfo getCurrentBundle() {
        return this.getBundleInfo(this.getCurrentBundleId());
    }

    public String getCurrentBundlePath() {
        String path = this.prefs.getString(this.CAP_SERVER_PATH, "public");
        if (path.trim().isEmpty()) {
            return "public";
        }
        return path;
    }

    public Boolean isUsingBuiltin() {
        return this.getCurrentBundlePath().equals("public");
    }

    public BundleInfo getFallbackBundle() {
        final String id = this.prefs.getString(FALLBACK_VERSION, BundleInfo.ID_BUILTIN);
        return this.getBundleInfo(id);
    }

    private void setFallbackBundle(final BundleInfo fallback) {
        this.editor.putString(FALLBACK_VERSION, fallback == null ? BundleInfo.ID_BUILTIN : fallback.getId());
        this.editor.commit();
    }

    public BundleInfo getNextBundle() {
        final String id = this.prefs.getString(NEXT_VERSION, null);
        if (id == null) return null;
        return this.getBundleInfo(id);
    }

    public boolean setNextBundle(final String next) {
        if (next == null) {
            this.editor.remove(NEXT_VERSION);
        } else {
            final BundleInfo newBundle = this.getBundleInfo(next);
            if (!newBundle.isBuiltin() && !this.bundleExists(next)) {
                return false;
            }
            this.editor.putString(NEXT_VERSION, next);
            this.setBundleStatus(next, BundleStatus.PENDING);
        }
        this.editor.commit();
        return true;
    }

    /**
     * Shuts down the stats scheduler and flushes any pending stats.
     * Should be called when the plugin is destroyed to prevent resource leaks.
     */
    public void shutdown() {
        // Cancel the scheduled task
        if (statsFlushTask != null) {
            statsFlushTask.cancel(false);
            statsFlushTask = null;
        }

        // Flush any remaining stats before shutdown
        flushStatsQueue();

        // Shutdown the scheduler
        statsScheduler.shutdown();
        try {
            if (!statsScheduler.awaitTermination(2, TimeUnit.SECONDS)) {
                statsScheduler.shutdownNow();
            }
        } catch (InterruptedException e) {
            statsScheduler.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
