/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package ee.forgr.capacitor_updater;

import static android.content.Context.RECEIVER_NOT_EXPORTED;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.os.Build;
import android.os.Bundle;
import android.util.Base64;
import android.util.Log;
import com.android.volley.BuildConfig;
import com.android.volley.DefaultRetryPolicy;
import com.android.volley.NetworkResponse;
import com.android.volley.Request;
import com.android.volley.RequestQueue;
import com.android.volley.VolleyError;
import com.android.volley.toolbox.HttpHeaderParser;
import com.android.volley.toolbox.JsonObjectRequest;
import com.getcapacitor.JSObject;
import com.getcapacitor.plugin.WebView;
import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.net.URLConnection;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import org.json.JSONException;
import org.json.JSONObject;

public class CapacitorUpdater {

  private static final String AB =
    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  private static final SecureRandom rnd = new SecureRandom();

  private static final String INFO_SUFFIX = "_info";

  private static final String FALLBACK_VERSION = "pastVersion";
  private static final String NEXT_VERSION = "nextVersion";
  private static final String bundleDirectory = "versions";

  public static final String TAG = "Capacitor-updater";
  public SharedPreferences.Editor editor;
  public SharedPreferences prefs;

  public RequestQueue requestQueue;

  public File documentsDir;
  public Boolean directUpdate = false;
  public Activity activity;
  public String PLUGIN_VERSION = "";
  public String versionBuild = "";
  public String versionCode = "";
  public String versionOs = "";

  public String customId = "";
  public String statsUrl = "";
  public String channelUrl = "";
  public String defaultChannel = "";
  public String appId = "";
  public String privateKey = "";
  public String deviceID = "";
  public int timeout = 20000;
  public PublicKey signKey = null;

  private final FilenameFilter filter = (f, name) -> {
    // ignore directories generated by mac os x
    return (
      !name.startsWith("__MACOSX") &&
      !name.startsWith(".") &&
      !name.startsWith(".DS_Store")
    );
  };

  private boolean isProd() {
    return !BuildConfig.DEBUG;
  }

  private boolean isEmulator() {
    return (
      (Build.BRAND.startsWith("generic") &&
        Build.DEVICE.startsWith("generic")) ||
      Build.FINGERPRINT.startsWith("generic") ||
      Build.FINGERPRINT.startsWith("unknown") ||
      Build.HARDWARE.contains("goldfish") ||
      Build.HARDWARE.contains("ranchu") ||
      Build.MODEL.contains("google_sdk") ||
      Build.MODEL.contains("Emulator") ||
      Build.MODEL.contains("Android SDK built for x86") ||
      Build.MANUFACTURER.contains("Genymotion") ||
      Build.PRODUCT.contains("sdk_google") ||
      Build.PRODUCT.contains("google_sdk") ||
      Build.PRODUCT.contains("sdk") ||
      Build.PRODUCT.contains("sdk_x86") ||
      Build.PRODUCT.contains("sdk_gphone64_arm64") ||
      Build.PRODUCT.contains("vbox86p") ||
      Build.PRODUCT.contains("emulator") ||
      Build.PRODUCT.contains("simulator")
    );
  }

  private int calcTotalPercent(
    final int percent,
    final int min,
    final int max
  ) {
    return (percent * (max - min)) / 100 + min;
  }

  void notifyDownload(final String id, final int percent) {}

  void directUpdateFinish(final BundleInfo latest) {}

  void notifyListeners(final String id, final JSObject res) {}

  private String randomString() {
    final StringBuilder sb = new StringBuilder(10);
    for (int i = 0; i < 10; i++) sb.append(AB.charAt(rnd.nextInt(AB.length())));
    return sb.toString();
  }

  private File unzip(final String id, final File zipFile, final String dest)
    throws IOException {
    final File targetDirectory = new File(this.documentsDir, dest);
    try (
      final BufferedInputStream bis = new BufferedInputStream(
        new FileInputStream(zipFile)
      );
      final ZipInputStream zis = new ZipInputStream(bis)
    ) {
      int count;
      final int bufferSize = 8192;
      final byte[] buffer = new byte[bufferSize];
      final long lengthTotal = zipFile.length();
      long lengthRead = bufferSize;
      int percent = 0;
      this.notifyDownload(id, 75);

      ZipEntry entry;
      while ((entry = zis.getNextEntry()) != null) {
        if (entry.getName().contains("\\")) {
          Log.e(
            TAG,
            "unzip: Windows path is not supported, please use unix path as require by zip RFC: " +
            entry.getName()
          );
          this.sendStats("windows_path_fail");
        }
        final File file = new File(targetDirectory, entry.getName());
        final String canonicalPath = file.getCanonicalPath();
        final String canonicalDir = targetDirectory.getCanonicalPath();
        final File dir = entry.isDirectory() ? file : file.getParentFile();

        if (!canonicalPath.startsWith(canonicalDir)) {
          this.sendStats("canonical_path_fail");
          throw new FileNotFoundException(
            "SecurityException, Failed to ensure directory is the start path : " +
            canonicalDir +
            " of " +
            canonicalPath
          );
        }

        assert dir != null;
        if (!dir.isDirectory() && !dir.mkdirs()) {
          this.sendStats("directory_path_fail");
          throw new FileNotFoundException(
            "Failed to ensure directory: " + dir.getAbsolutePath()
          );
        }

        if (entry.isDirectory()) {
          continue;
        }

        try (final FileOutputStream outputStream = new FileOutputStream(file)) {
          while ((count = zis.read(buffer)) != -1) outputStream.write(
            buffer,
            0,
            count
          );
        }

        final int newPercent = (int) ((lengthRead / (float) lengthTotal) * 100);
        if (lengthTotal > 1 && newPercent != percent) {
          percent = newPercent;
          this.notifyDownload(id, this.calcTotalPercent(percent, 75, 90));
        }

        lengthRead += entry.getCompressedSize();
      }
      return targetDirectory;
    } catch (IOException e) {
      this.sendStats("unzip_fail");
      throw new IOException("Failed to unzip: " + zipFile.getPath());
    }
  }

  private void flattenAssets(final File sourceFile, final String dest)
    throws IOException {
    if (!sourceFile.exists()) {
      throw new FileNotFoundException(
        "Source file not found: " + sourceFile.getPath()
      );
    }
    final File destinationFile = new File(this.documentsDir, dest);
    Objects.requireNonNull(destinationFile.getParentFile()).mkdirs();
    final String[] entries = sourceFile.list(this.filter);
    if (entries == null || entries.length == 0) {
      throw new IOException(
        "Source file was not a directory or was empty: " + sourceFile.getPath()
      );
    }
    if (entries.length == 1 && !"index.html".equals(entries[0])) {
      final File child = new File(sourceFile, entries[0]);
      child.renameTo(destinationFile);
    } else {
      sourceFile.renameTo(destinationFile);
    }
    sourceFile.delete();
  }

  public void onResume() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
      IntentFilter filter = new IntentFilter();
      filter.addAction(DownloadService.NOTIFICATION);
      filter.addAction(DownloadService.PERCENTDOWNLOAD);
      this.activity.registerReceiver(
          receiver,
          filter,
          RECEIVER_NOT_EXPORTED
        );
    } else {
      IntentFilter filter = new IntentFilter();
      filter.addAction(DownloadService.NOTIFICATION);
      filter.addAction(DownloadService.PERCENTDOWNLOAD);
      this.activity.registerReceiver(
          receiver,
          filter
        );
    }
  }

  public void onPause() {
    this.activity.unregisterReceiver(receiver);
  }

  private final BroadcastReceiver receiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
      String action = intent.getAction();
      Bundle bundle = intent.getExtras();
      if (bundle != null) {
        if (Objects.equals(action, DownloadService.PERCENTDOWNLOAD)) {
          String id = bundle.getString(DownloadService.ID);
          int percent = bundle.getInt(DownloadService.PERCENT);
          CapacitorUpdater.this.notifyDownload(id, percent);
        } else if (Objects.equals(action, DownloadService.NOTIFICATION)) {
          String id = bundle.getString(DownloadService.ID);
          String dest = bundle.getString(DownloadService.FILEDEST);
          String version = bundle.getString(DownloadService.VERSION);
          String sessionKey = bundle.getString(DownloadService.SESSIONKEY);
          String checksum = bundle.getString(DownloadService.CHECKSUM);
          String error = bundle.getString(DownloadService.ERROR);
          String signature = bundle.getString(DownloadService.SIGNATURE);
          Log.i(
            CapacitorUpdater.TAG,
            "res " +
            id +
            " " +
            dest +
            " " +
            version +
            " " +
            sessionKey +
            " " +
            checksum +
            " " +
            signature +
            " " +
            error
          );
          if (dest == null) {
            final JSObject ret = new JSObject();
            ret.put(
              "version",
              CapacitorUpdater.this.getCurrentBundle().getVersionName()
            );
            if ("low_mem_fail".equals(error)) {
              CapacitorUpdater.this.sendStats("low_mem_fail", version);
            }
            ret.put("error", "download_fail");
            CapacitorUpdater.this.sendStats("download_fail", version);
            CapacitorUpdater.this.notifyListeners("downloadFailed", ret);
            return;
          }
          CapacitorUpdater.this.finishDownload(
              id,
              dest,
              version,
              sessionKey,
              checksum,
              signature,
              true
            );
        } else {
          Log.i(TAG, "Unknown action " + action);
        }
      }
    }
  };

  public Boolean finishDownload(
    String id,
    String dest,
    String version,
    String sessionKey,
    String checksumRes,
    String signature,
    Boolean setNext
  ) {
    File downloaded = null;
    String checksum;

    try {
      this.notifyDownload(id, 71);
      downloaded = new File(this.documentsDir, dest);

      boolean valid = verifyBundleSignature(version, downloaded, signature);
      if (!valid) {
        Log.e(
          CapacitorUpdater.TAG,
          "Invalid signature, cannot accept download"
        );

        this.sendStats("invalid_signature", version);
        throw new GeneralSecurityException(
          "Signature is not valid, cannot accept update"
        );
      } else {
        Log.i(CapacitorUpdater.TAG, "Valid signature");
      }

      this.decryptFile(downloaded, sessionKey, version);
      checksum = this.calcChecksum(downloaded);
      if (
        checksumRes != null &&
        !checksumRes.isEmpty() &&
        !checksumRes.equals(checksum)
      ) {
        Log.e(
          CapacitorUpdater.TAG,
          "Error checksum " + checksumRes + " " + checksum
        );
        this.sendStats("checksum_fail");
        throw new IOException("Checksum failed: " + id);
      }
    } catch (IOException | GeneralSecurityException e) {
      final Boolean res = this.delete(id);
      if (!res) {
        Log.i(CapacitorUpdater.TAG, "Double error, cannot cleanup: " + version);
      }

      final JSObject ret = new JSObject();
      ret.put(
        "version",
        CapacitorUpdater.this.getCurrentBundle().getVersionName()
      );

      CapacitorUpdater.this.notifyListeners("downloadFailed", ret);
      CapacitorUpdater.this.sendStats("download_fail");
      return false;
    }

    try {
      final File unzipped = this.unzip(id, downloaded, this.randomString());
      downloaded.delete();
      this.notifyDownload(id, 91);
      final String idName = bundleDirectory + "/" + id;
      this.flattenAssets(unzipped, idName);
      this.notifyDownload(id, 100);
      this.saveBundleInfo(id, null);
      BundleInfo next = new BundleInfo(
        id,
        version,
        BundleStatus.PENDING,
        new Date(System.currentTimeMillis()),
        checksum
      );
      this.saveBundleInfo(id, next);

      final JSObject ret = new JSObject();
      ret.put("bundle", next.toJSON());
      CapacitorUpdater.this.notifyListeners("updateAvailable", ret);
      if (setNext) {
        if (this.directUpdate) {
          CapacitorUpdater.this.directUpdateFinish(next);
          this.directUpdate = false;
        } else {
          this.setNextBundle(next.getId());
        }
      }
    } catch (IOException e) {
      e.printStackTrace();
      final JSObject ret = new JSObject();
      ret.put(
        "version",
        CapacitorUpdater.this.getCurrentBundle().getVersionName()
      );
      CapacitorUpdater.this.notifyListeners("downloadFailed", ret);
      CapacitorUpdater.this.sendStats("download_fail");
      return false;
    }
    return true;
  }

  private void downloadFileBackground(
    final String id,
    final String url,
    final String version,
    final String sessionKey,
    final String checksum,
    final String dest,
    final String signature
  ) {
    Intent intent = new Intent(this.activity, DownloadService.class);
    intent.putExtra(DownloadService.URL, url);
    intent.putExtra(DownloadService.FILEDEST, dest);
    intent.putExtra(
      DownloadService.DOCDIR,
      this.documentsDir.getAbsolutePath()
    );
    intent.putExtra(DownloadService.ID, id);
    intent.putExtra(DownloadService.VERSION, version);
    intent.putExtra(DownloadService.SESSIONKEY, sessionKey);
    intent.putExtra(DownloadService.CHECKSUM, checksum);
    intent.putExtra(DownloadService.SIGNATURE, signature);
    this.activity.startService(intent);
  }

  private void downloadFile(
    final String id,
    final String url,
    final String dest
  ) throws IOException {
    final URL u = new URL(url);
    final URLConnection connection = u.openConnection();

    final File target = new File(this.documentsDir, dest);
    Objects.requireNonNull(target.getParentFile()).mkdirs();
    target.createNewFile();

    final long totalLength = connection.getContentLength();
    final int bufferSize = 1024;
    final byte[] buffer = new byte[bufferSize];
    int length;

    int bytesRead = bufferSize;
    int percent = 0;
    this.notifyDownload(id, 10);
    try (
      final InputStream is = connection.getInputStream();
      final DataInputStream dis = new DataInputStream(is);
      final FileOutputStream fos = new FileOutputStream(target)
    ) {
      while ((length = dis.read(buffer)) > 0) {
        fos.write(buffer, 0, length);
        final int newPercent = (int) ((bytesRead / (float) totalLength) * 100);
        if (totalLength > 1 && newPercent != percent) {
          percent = newPercent;
          this.notifyDownload(id, this.calcTotalPercent(percent, 10, 70));
        }
        bytesRead += length;
      }
    } catch (OutOfMemoryError e) {
      Log.e(TAG, "OutOfMemoryError while downloading file", e);
      this.sendStats("low_mem_fail");
      throw new IOException("OutOfMemoryError while downloading file");
    }
  }

  private void deleteDirectory(final File file) throws IOException {
    if (file.isDirectory()) {
      final File[] entries = file.listFiles();
      if (entries != null) {
        for (final File entry : entries) {
          this.deleteDirectory(entry);
        }
      }
    }
    if (!file.delete()) {
      throw new IOException("Failed to delete: " + file);
    }
  }

  private void setCurrentBundle(final File bundle) {
    this.editor.putString(WebView.CAP_SERVER_PATH, bundle.getPath());
    Log.i(TAG, "Current bundle set to: " + bundle);
    this.editor.commit();
  }

  private String calcChecksum(File file) {
    final int BUFFER_SIZE = 1024 * 1024 * 5; // 5 MB buffer size
    CRC32 crc = new CRC32();

    try (FileInputStream fis = new FileInputStream(file)) {
      byte[] buffer = new byte[BUFFER_SIZE];
      int length;
      while ((length = fis.read(buffer)) != -1) {
        crc.update(buffer, 0, length);
      }
      return String.format("%08x", crc.getValue());
    } catch (IOException e) {
      System.err.println(
        TAG + " Cannot calc checksum: " + file.getPath() + " " + e.getMessage()
      );
      return "";
    }
  }

  private boolean verifyBundleSignature(
    final String version,
    final File file,
    final String signatureStr
  ) throws GeneralSecurityException, IOException {
    if (this.signKey == null) {
      Log.i(TAG, "Signing not configured");
      return true;
    }

    if (signatureStr.isEmpty()) {
      Log.i(TAG, "Signature required but none provided");
      this.sendStats("signature_not_provided", version);
      throw new GeneralSecurityException(
        "Signature was required but none was provided"
      );
    }

    byte[] providedSignatureBytes = Base64.decode(
      signatureStr.getBytes(StandardCharsets.UTF_8),
      Base64.DEFAULT
    );

    Signature signature = Signature.getInstance("SHA512withRSA");
    signature.initVerify(this.signKey);

    byte[] content = new byte[(int) file.length()];

    try (
      final FileInputStream fis = new FileInputStream(file);
      final BufferedInputStream bis = new BufferedInputStream(fis);
      final DataInputStream dis = new DataInputStream(bis)
    ) {
      dis.readFully(content);
      dis.close();

      signature.update(content);
      return signature.verify(providedSignatureBytes);
    }
  }

  private void decryptFile(
    final File file,
    final String ivSessionKey,
    final String version
  ) throws IOException {
    // (str != null && !str.isEmpty())
    if (
      this.privateKey == null ||
      this.privateKey.isEmpty() ||
      ivSessionKey == null ||
      ivSessionKey.isEmpty() ||
      ivSessionKey.split(":").length != 2
    ) {
      Log.i(TAG, "Cannot found privateKey or sessionKey");
      return;
    }
    try {
      String ivB64 = ivSessionKey.split(":")[0];
      String sessionKeyB64 = ivSessionKey.split(":")[1];
      byte[] iv = Base64.decode(ivB64.getBytes(), Base64.DEFAULT);
      byte[] sessionKey = Base64.decode(
        sessionKeyB64.getBytes(),
        Base64.DEFAULT
      );
      PrivateKey pKey = CryptoCipher.stringToPrivateKey(this.privateKey);
      byte[] decryptedSessionKey = CryptoCipher.decryptRSA(sessionKey, pKey);
      SecretKey sKey = CryptoCipher.byteToSessionKey(decryptedSessionKey);
      byte[] content = new byte[(int) file.length()];

      try (
        final FileInputStream fis = new FileInputStream(file);
        final BufferedInputStream bis = new BufferedInputStream(fis);
        final DataInputStream dis = new DataInputStream(bis)
      ) {
        dis.readFully(content);
        dis.close();
        byte[] decrypted = CryptoCipher.decryptAES(content, sKey, iv);
        // write the decrypted string to the file
        try (
          final FileOutputStream fos = new FileOutputStream(
            file.getAbsolutePath()
          )
        ) {
          fos.write(decrypted);
        }
      }
    } catch (GeneralSecurityException e) {
      Log.i(TAG, "decryptFile fail");
      this.sendStats("decrypt_fail", version);
      e.printStackTrace();
      throw new IOException("GeneralSecurityException");
    }
  }

  public void downloadBackground(
    final String url,
    final String version,
    final String sessionKey,
    final String checksum,
    final String signature
  ) {
    final String id = this.randomString();
    this.saveBundleInfo(
        id,
        new BundleInfo(
          id,
          version,
          BundleStatus.DOWNLOADING,
          new Date(System.currentTimeMillis()),
          ""
        )
      );
    this.notifyDownload(id, 0);
    this.notifyDownload(id, 5);
    this.downloadFileBackground(
        id,
        url,
        version,
        sessionKey,
        checksum,
        this.randomString(),
        signature
      );
  }

  public BundleInfo download(
    final String url,
    final String version,
    final String sessionKey,
    final String checksum,
    final String signature
  ) throws IOException {
    final String id = this.randomString();
    this.saveBundleInfo(
        id,
        new BundleInfo(
          id,
          version,
          BundleStatus.DOWNLOADING,
          new Date(System.currentTimeMillis()),
          ""
        )
      );
    this.notifyDownload(id, 0);
    this.notifyDownload(id, 5);
    final String dest = this.randomString();
    this.downloadFile(id, url, dest);
    final Boolean finished =
      this.finishDownload(
          id,
          dest,
          version,
          sessionKey,
          checksum,
          signature,
          false
        );
    final BundleStatus status = finished
      ? BundleStatus.PENDING
      : BundleStatus.ERROR;
    BundleInfo info = new BundleInfo(
      id,
      version,
      status,
      new Date(System.currentTimeMillis()),
      checksum
    );
    this.saveBundleInfo(id, info);
    return info;
  }

  public List<BundleInfo> list() {
    final List<BundleInfo> res = new ArrayList<>();
    final File destHot = new File(this.documentsDir, bundleDirectory);
    Log.d(TAG, "list File : " + destHot.getPath());
    if (destHot.exists()) {
      for (final File i : Objects.requireNonNull(destHot.listFiles())) {
        final String id = i.getName();
        res.add(this.getBundleInfo(id));
      }
    } else {
      Log.i(TAG, "No versions available to list" + destHot);
    }
    return res;
  }

  public Boolean delete(final String id, final Boolean removeInfo)
    throws IOException {
    final BundleInfo deleted = this.getBundleInfo(id);
    if (deleted.isBuiltin() || this.getCurrentBundleId().equals(id)) {
      Log.e(TAG, "Cannot delete " + id);
      return false;
    }
    final File bundle = new File(this.documentsDir, bundleDirectory + "/" + id);
    if (bundle.exists()) {
      this.deleteDirectory(bundle);
      if (removeInfo) {
        this.removeBundleInfo(id);
      } else {
        this.saveBundleInfo(id, deleted.setStatus(BundleStatus.DELETED));
      }
      return true;
    }
    Log.e(TAG, "bundle removed: " + deleted.getVersionName());
    this.sendStats("delete", deleted.getVersionName());
    return false;
  }

  public Boolean delete(final String id) {
    try {
      return this.delete(id, true);
    } catch (IOException e) {
      e.printStackTrace();
      Log.i(
        CapacitorUpdater.TAG,
        "Failed to delete bundle (" + id + ")" + "\nError:\n" + e.toString()
      );
      return false;
    }
  }

  private File getBundleDirectory(final String id) {
    return new File(this.documentsDir, bundleDirectory + "/" + id);
  }

  private boolean bundleExists(final String id) {
    final File bundle = this.getBundleDirectory(id);
    final BundleInfo bundleInfo = this.getBundleInfo(id);
    return (
      bundle.isDirectory() &&
      bundle.exists() &&
      new File(bundle.getPath(), "/index.html").exists() &&
      !bundleInfo.isDeleted()
    );
  }

  public Boolean set(final BundleInfo bundle) {
    return this.set(bundle.getId());
  }

  public Boolean set(final String id) {
    final BundleInfo newBundle = this.getBundleInfo(id);
    if (newBundle.isBuiltin()) {
      this.reset();
      return true;
    }
    final File bundle = this.getBundleDirectory(id);
    Log.i(TAG, "Setting next active bundle: " + id);
    if (this.bundleExists(id)) {
      var currentBundleName = this.getCurrentBundle().getVersionName();
      this.setCurrentBundle(bundle);
      this.setBundleStatus(id, BundleStatus.PENDING);
      this.sendStats("set", newBundle.getVersionName(), currentBundleName);
      return true;
    }
    this.setBundleStatus(id, BundleStatus.ERROR);
    this.sendStats("set_fail", newBundle.getVersionName());
    return false;
  }

  public void autoReset() {
    final BundleInfo currentBundle = this.getCurrentBundle();
    if (
      !currentBundle.isBuiltin() && !this.bundleExists(currentBundle.getId())
    ) {
      Log.i(TAG, "Folder at bundle path does not exist. Triggering reset.");
      this.reset();
    }
  }

  public void reset() {
    this.reset(false);
  }

  public void setSuccess(final BundleInfo bundle, Boolean autoDeletePrevious) {
    this.setBundleStatus(bundle.getId(), BundleStatus.SUCCESS);
    final BundleInfo fallback = this.getFallbackBundle();
    Log.d(CapacitorUpdater.TAG, "Fallback bundle is: " + fallback);
    Log.i(
      CapacitorUpdater.TAG,
      "Version successfully loaded: " + bundle.getVersionName()
    );
    if (autoDeletePrevious && !fallback.isBuiltin()) {
      final Boolean res = this.delete(fallback.getId());
      if (res) {
        Log.i(
          CapacitorUpdater.TAG,
          "Deleted previous bundle: " + fallback.getVersionName()
        );
      }
    }
    this.setFallbackBundle(bundle);
  }

  public void setError(final BundleInfo bundle) {
    this.setBundleStatus(bundle.getId(), BundleStatus.ERROR);
  }

  public void reset(final boolean internal) {
    Log.d(CapacitorUpdater.TAG, "reset: " + internal);
    var currentBundleName = this.getCurrentBundle().getVersionName();
    this.setCurrentBundle(new File("public"));
    this.setFallbackBundle(null);
    this.setNextBundle(null);
    if (!internal) {
      this.sendStats(
          "reset",
          this.getCurrentBundle().getVersionName(),
          currentBundleName
        );
    }
  }

  private JSONObject createInfoObject() throws JSONException {
    JSONObject json = new JSONObject();
    json.put("platform", "android");
    json.put("device_id", this.deviceID);
    json.put("app_id", this.appId);
    json.put("custom_id", this.customId);
    json.put("version_build", this.versionBuild);
    json.put("version_code", this.versionCode);
    json.put("version_os", this.versionOs);
    json.put("version_name", this.getCurrentBundle().getVersionName());
    json.put("plugin_version", this.PLUGIN_VERSION);
    json.put("is_emulator", this.isEmulator());
    json.put("is_prod", this.isProd());
    json.put("defaultChannel", this.defaultChannel);
    return json;
  }

  private JsonObjectRequest setRetryPolicy(JsonObjectRequest request) {
    request.setRetryPolicy(
      new DefaultRetryPolicy(
        this.timeout,
        DefaultRetryPolicy.DEFAULT_MAX_RETRIES,
        DefaultRetryPolicy.DEFAULT_BACKOFF_MULT
      )
    );
    return request;
  }

  private JSObject createError(String message, VolleyError error) {
    NetworkResponse response = error.networkResponse;
    final JSObject retError = new JSObject();
    retError.put("error", "response_error");
    if (response != null) {
      try {
        String json = new String(
          response.data,
          HttpHeaderParser.parseCharset(response.headers)
        );
        retError.put("message", message + ": " + json);
      } catch (UnsupportedEncodingException e) {
        retError.put("message", message + ": " + e);
      }
    } else {
      retError.put("message", message + ": " + error);
    }
    Log.e(TAG, message + ": " + retError);
    return retError;
  }

  public void getLatest(final String updateUrl, final Callback callback) {
    JSONObject json;
    try {
      json = this.createInfoObject();
    } catch (JSONException e) {
      Log.e(TAG, "Error getLatest JSONException", e);
      e.printStackTrace();
      final JSObject retError = new JSObject();
      retError.put("message", "Cannot get info: " + e);
      retError.put("error", "json_error");
      callback.callback(retError);
      return;
    }

    Log.i(CapacitorUpdater.TAG, "Auto-update parameters: " + json);
    // Building a request
    JsonObjectRequest request = new JsonObjectRequest(
      Request.Method.POST,
      updateUrl,
      json,
      res -> {
        final JSObject ret = new JSObject();
        Iterator<String> keys = res.keys();
        while (keys.hasNext()) {
          String key = keys.next();
          if (res.has(key)) {
            try {
              if ("session_key".equals(key)) {
                ret.put("sessionKey", res.get(key));
              } else {
                ret.put(key, res.get(key));
              }
            } catch (JSONException e) {
              e.printStackTrace();
              final JSObject retError = new JSObject();
              retError.put("message", "Cannot set info: " + e);
              retError.put("error", "response_error");
              callback.callback(retError);
            }
          }
        }
        callback.callback(ret);
      },
      error ->
        callback.callback(
          CapacitorUpdater.this.createError("Error get latest", error)
        )
    );
    this.requestQueue.add(setRetryPolicy(request));
  }

  public void unsetChannel(final Callback callback) {
    String channelUrl = this.channelUrl;
    if (channelUrl == null || channelUrl.isEmpty()) {
      Log.e(TAG, "Channel URL is not set");
      final JSObject retError = new JSObject();
      retError.put("message", "channelUrl missing");
      retError.put("error", "missing_config");
      callback.callback(retError);
      return;
    }
    JSONObject json;
    try {
      json = this.createInfoObject();
    } catch (JSONException e) {
      Log.e(TAG, "Error unsetChannel JSONException", e);
      e.printStackTrace();
      final JSObject retError = new JSObject();
      retError.put("message", "Cannot get info: " + e);
      retError.put("error", "json_error");
      callback.callback(retError);
      return;
    }
    // Building a request
    JsonObjectRequest request = new JsonObjectRequest(
      Request.Method.DELETE,
      channelUrl,
      json,
      res -> {
        final JSObject ret = new JSObject();
        Iterator<String> keys = res.keys();
        while (keys.hasNext()) {
          String key = keys.next();
          if (res.has(key)) {
            try {
              ret.put(key, res.get(key));
            } catch (JSONException e) {
              e.printStackTrace();
              final JSObject retError = new JSObject();
              retError.put("message", "Cannot unset channel: " + e);
              retError.put("error", "response_error");
              callback.callback(ret);
            }
          }
        }
        Log.i(TAG, "Channel unset");
        callback.callback(ret);
      },
      error ->
        callback.callback(
          CapacitorUpdater.this.createError("Error unset channel", error)
        )
    );
    this.requestQueue.add(setRetryPolicy(request));
  }

  public void setChannel(final String channel, final Callback callback) {
    String channelUrl = this.channelUrl;
    if (channelUrl == null || channelUrl.isEmpty()) {
      Log.e(TAG, "Channel URL is not set");
      final JSObject retError = new JSObject();
      retError.put("message", "channelUrl missing");
      retError.put("error", "missing_config");
      callback.callback(retError);
      return;
    }
    JSONObject json;
    try {
      json = this.createInfoObject();
      json.put("channel", channel);
    } catch (JSONException e) {
      Log.e(TAG, "Error setChannel JSONException", e);
      e.printStackTrace();
      final JSObject retError = new JSObject();
      retError.put("message", "Cannot get info: " + e);
      retError.put("error", "json_error");
      callback.callback(retError);
      return;
    }
    // Building a request
    JsonObjectRequest request = new JsonObjectRequest(
      Request.Method.POST,
      channelUrl,
      json,
      res -> {
        final JSObject ret = new JSObject();
        Iterator<String> keys = res.keys();
        while (keys.hasNext()) {
          String key = keys.next();
          if (res.has(key)) {
            try {
              ret.put(key, res.get(key));
            } catch (JSONException e) {
              e.printStackTrace();
              final JSObject retError = new JSObject();
              retError.put("message", "Cannot set channel: " + e);
              retError.put("error", "response_error");
              callback.callback(ret);
            }
          }
        }
        Log.i(TAG, "Channel set to \"" + channel);
        callback.callback(ret);
      },
      error ->
        callback.callback(
          CapacitorUpdater.this.createError("Error set channel", error)
        )
    );
    this.requestQueue.add(setRetryPolicy(request));
  }

  public void getChannel(final Callback callback) {
    String channelUrl = this.channelUrl;
    if (channelUrl == null || channelUrl.isEmpty()) {
      Log.e(TAG, "Channel URL is not set");
      final JSObject retError = new JSObject();
      retError.put("message", "Channel URL is not set");
      retError.put("error", "missing_config");
      callback.callback(retError);
      return;
    }
    JSONObject json;
    try {
      json = this.createInfoObject();
    } catch (JSONException e) {
      Log.e(TAG, "Error getChannel JSONException", e);
      e.printStackTrace();
      final JSObject retError = new JSObject();
      retError.put("message", "Cannot get info: " + e);
      retError.put("error", "json_error");
      callback.callback(retError);
      return;
    }
    // Building a request
    JsonObjectRequest request = new JsonObjectRequest(
      Request.Method.PUT,
      channelUrl,
      json,
      res -> {
        final JSObject ret = new JSObject();
        Iterator<String> keys = res.keys();
        while (keys.hasNext()) {
          String key = keys.next();
          if (res.has(key)) {
            try {
              ret.put(key, res.get(key));
            } catch (JSONException e) {
              e.printStackTrace();
            }
          }
        }
        Log.i(TAG, "Channel get to \"" + ret);
        callback.callback(ret);
      },
      error ->
        callback.callback(
          CapacitorUpdater.this.createError("Error get channel", error)
        )
    );
    this.requestQueue.add(setRetryPolicy(request));
  }

  public void sendStats(final String action) {
    this.sendStats(action, this.getCurrentBundle().getVersionName());
  }

  public void sendStats(final String action, final String versionName) {
    this.sendStats(action, versionName, "");
  }

  public void sendStats(
    final String action,
    final String versionName,
    final String oldVersionName
  ) {
    String statsUrl = this.statsUrl;
    if (statsUrl == null || statsUrl.isEmpty()) {
      return;
    }
    JSONObject json;
    try {
      json = this.createInfoObject();
      json.put("version_name", versionName);
      json.put("old_version_name", oldVersionName);
      json.put("action", action);
    } catch (JSONException e) {
      Log.e(TAG, "Error sendStats JSONException", e);
      e.printStackTrace();
      return;
    }
    // Building a request
    JsonObjectRequest request = new JsonObjectRequest(
      Request.Method.POST,
      statsUrl,
      json,
      response ->
        Log.i(TAG, "Stats send for \"" + action + "\", version " + versionName),
      error -> CapacitorUpdater.this.createError("Error send stats", error)
    );
    this.requestQueue.add(setRetryPolicy(request));
  }

  public BundleInfo getBundleInfo(final String id) {
    String trueId = BundleInfo.VERSION_UNKNOWN;
    if (id != null) {
      trueId = id;
    }
    BundleInfo result;
    if (BundleInfo.ID_BUILTIN.equals(trueId)) {
      result = new BundleInfo(trueId, null, BundleStatus.SUCCESS, "", "");
    } else if (BundleInfo.VERSION_UNKNOWN.equals(trueId)) {
      result = new BundleInfo(trueId, null, BundleStatus.ERROR, "", "");
    } else {
      try {
        String stored = this.prefs.getString(trueId + INFO_SUFFIX, "");
        result = BundleInfo.fromJSON(stored);
      } catch (JSONException e) {
        Log.e(TAG, "Failed to parse info for bundle [" + trueId + "] ", e);
        result = new BundleInfo(trueId, null, BundleStatus.PENDING, "", "");
      }
    }
    // Log.d(TAG, "Returning info [" + trueId + "] " + result);
    return result;
  }

  public BundleInfo getBundleInfoByName(final String versionName) {
    final List<BundleInfo> installed = this.list();
    for (final BundleInfo i : installed) {
      if (i.getVersionName().equals(versionName)) {
        return i;
      }
    }
    return null;
  }

  private void removeBundleInfo(final String id) {
    this.saveBundleInfo(id, null);
  }

  public void saveBundleInfo(final String id, final BundleInfo info) {
    if (
      id == null || (info != null && (info.isBuiltin() || info.isUnknown()))
    ) {
      Log.d(TAG, "Not saving info for bundle: [" + id + "] " + info);
      return;
    }

    if (info == null) {
      Log.d(TAG, "Removing info for bundle [" + id + "]");
      this.editor.remove(id + INFO_SUFFIX);
    } else {
      final BundleInfo update = info.setId(id);
      Log.d(TAG, "Storing info for bundle [" + id + "] " + update.toString());
      this.editor.putString(id + INFO_SUFFIX, update.toString());
    }
    this.editor.commit();
  }

  private void setBundleStatus(final String id, final BundleStatus status) {
    if (id != null && status != null) {
      BundleInfo info = this.getBundleInfo(id);
      Log.d(TAG, "Setting status for bundle [" + id + "] to " + status);
      this.saveBundleInfo(id, info.setStatus(status));
    }
  }

  private String getCurrentBundleId() {
    if (this.isUsingBuiltin()) {
      return BundleInfo.ID_BUILTIN;
    } else {
      final String path = this.getCurrentBundlePath();
      return path.substring(path.lastIndexOf('/') + 1);
    }
  }

  public BundleInfo getCurrentBundle() {
    return this.getBundleInfo(this.getCurrentBundleId());
  }

  public String getCurrentBundlePath() {
    String path = this.prefs.getString(WebView.CAP_SERVER_PATH, "public");
    if (path.trim().isEmpty()) {
      return "public";
    }
    return path;
  }

  public Boolean isUsingBuiltin() {
    return this.getCurrentBundlePath().equals("public");
  }

  public BundleInfo getFallbackBundle() {
    final String id =
      this.prefs.getString(FALLBACK_VERSION, BundleInfo.ID_BUILTIN);
    return this.getBundleInfo(id);
  }

  private void setFallbackBundle(final BundleInfo fallback) {
    this.editor.putString(
        FALLBACK_VERSION,
        fallback == null ? BundleInfo.ID_BUILTIN : fallback.getId()
      );
    this.editor.commit();
  }

  public BundleInfo getNextBundle() {
    final String id = this.prefs.getString(NEXT_VERSION, null);
    if (id == null) return null;
    return this.getBundleInfo(id);
  }

  public boolean setNextBundle(final String next) {
    if (next == null) {
      this.editor.remove(NEXT_VERSION);
    } else {
      final BundleInfo newBundle = this.getBundleInfo(next);
      if (!newBundle.isBuiltin() && !this.bundleExists(next)) {
        return false;
      }
      this.editor.putString(NEXT_VERSION, next);
      this.setBundleStatus(next, BundleStatus.PENDING);
    }
    this.editor.commit();
    return true;
  }
}
